// Code generated by protoc-gen-go. DO NOT EDIT.
// source: anchor/anchor.proto

package anchor // import "github.com/SouthbankSoftware/proofable/pkg/protos/anchor"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import empty "github.com/golang/protobuf/ptypes/empty"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Type represents an anchor type
type Anchor_Type int32

const (
	// ETH is the anchor type for Ethereum Testnet
	Anchor_ETH Anchor_Type = 0
	// ETH_MAINNET is the anchor type for Ethereum Mainnet
	Anchor_ETH_MAINNET Anchor_Type = 3
	// ETH_ELASTOS is the anchor type for Elastos
	Anchor_ETH_ELASTOS Anchor_Type = 4
	// BTC is the anchor type for Bitcoin Testnet
	Anchor_BTC Anchor_Type = 1
	// BTC_MAINNET is the anchor type for Bitcoin Mainnet
	Anchor_BTC_MAINNET Anchor_Type = 5
	// CHP is the anchor type for Chainpoint (planned)
	Anchor_CHP Anchor_Type = 2
)

var Anchor_Type_name = map[int32]string{
	0: "ETH",
	3: "ETH_MAINNET",
	4: "ETH_ELASTOS",
	1: "BTC",
	5: "BTC_MAINNET",
	2: "CHP",
}
var Anchor_Type_value = map[string]int32{
	"ETH":         0,
	"ETH_MAINNET": 3,
	"ETH_ELASTOS": 4,
	"BTC":         1,
	"BTC_MAINNET": 5,
	"CHP":         2,
}

func (x Anchor_Type) String() string {
	return proto.EnumName(Anchor_Type_name, int32(x))
}
func (Anchor_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{0, 0}
}

// Status represents an anchor's status
type Anchor_Status int32

const (
	// Error means the anchor has an error
	Anchor_ERROR Anchor_Status = 0
	// STOPPED means the anchor is stopped
	Anchor_STOPPED Anchor_Status = 1
	// RUNNING means the anchor is running
	Anchor_RUNNING Anchor_Status = 2
)

var Anchor_Status_name = map[int32]string{
	0: "ERROR",
	1: "STOPPED",
	2: "RUNNING",
}
var Anchor_Status_value = map[string]int32{
	"ERROR":   0,
	"STOPPED": 1,
	"RUNNING": 2,
}

func (x Anchor_Status) String() string {
	return proto.EnumName(Anchor_Status_name, int32(x))
}
func (Anchor_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{0, 1}
}

// Status represents a batch's status
type Batch_Status int32

const (
	// ERROR means the batch has an error. FLOW: * -> ERROR
	Batch_ERROR Batch_Status = 0
	// BATCHING means the batch is batching for more hashes. FLOW: created_at ->
	// BATCHING -> flushed_at
	Batch_BATCHING Batch_Status = 1
	// QUEUING means the batch is queuing to be processed. FLOW: flushed_at ->
	// QUEUING -> started_at
	Batch_QUEUING Batch_Status = 2
	// PROCESSING means the batch is constructing merkle roots and submitting
	// hashes. FLOW: started_at -> PROCESSING -> submitted_at
	Batch_PROCESSING Batch_Status = 3
	// PENDING means the batch's root hash is pending to be confirmed. FLOW:
	// submitted_at -> PENDING -> finalized_at
	Batch_PENDING Batch_Status = 4
	// CONFIRMED means the batch's root hash is confirmed by the anchor's
	// Blockchain. FLOW: finalized_at -> CONFIRMED
	Batch_CONFIRMED Batch_Status = 5
)

var Batch_Status_name = map[int32]string{
	0: "ERROR",
	1: "BATCHING",
	2: "QUEUING",
	3: "PROCESSING",
	4: "PENDING",
	5: "CONFIRMED",
}
var Batch_Status_value = map[string]int32{
	"ERROR":      0,
	"BATCHING":   1,
	"QUEUING":    2,
	"PROCESSING": 3,
	"PENDING":    4,
	"CONFIRMED":  5,
}

func (x Batch_Status) String() string {
	return proto.EnumName(Batch_Status_name, int32(x))
}
func (Batch_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{1, 0}
}

// Format represents a proof format
type Proof_Format int32

const (
	// CHP_PATH means Chainpoint Path format, which is the format used by
	// Chainpoint
	Proof_CHP_PATH Proof_Format = 0
	// ETH_TRIE means Ethereum Trie format
	Proof_ETH_TRIE Proof_Format = 1
	// CHP_PATH_SIGNED means signed Chainpoint Path format
	Proof_CHP_PATH_SIGNED Proof_Format = 2
	// ETH_TRIE_SIGNED means signed Ethereum Trie format
	Proof_ETH_TRIE_SIGNED Proof_Format = 3
)

var Proof_Format_name = map[int32]string{
	0: "CHP_PATH",
	1: "ETH_TRIE",
	2: "CHP_PATH_SIGNED",
	3: "ETH_TRIE_SIGNED",
}
var Proof_Format_value = map[string]int32{
	"CHP_PATH":        0,
	"ETH_TRIE":        1,
	"CHP_PATH_SIGNED": 2,
	"ETH_TRIE_SIGNED": 3,
}

func (x Proof_Format) String() string {
	return proto.EnumName(Proof_Format_name, int32(x))
}
func (Proof_Format) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{2, 0}
}

// Anchor represents an anchor of a Blockchain, through which a hash can be
// anchored to that Blockchain
type Anchor struct {
	// Type is the anchor type
	Type Anchor_Type `protobuf:"varint,1,opt,name=type,proto3,enum=anchor.Anchor_Type" json:"type,omitempty"`
	// Status is the anchor status
	Status Anchor_Status `protobuf:"varint,2,opt,name=status,proto3,enum=anchor.Anchor_Status" json:"status,omitempty"`
	// Error is the error message when the anchor status is ERROR
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	// SupportedFormats are the supported proof formats of the anchor
	SupportedFormats     []Proof_Format `protobuf:"varint,4,rep,packed,name=supported_formats,json=supportedFormats,proto3,enum=anchor.Proof_Format" json:"supported_formats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Anchor) Reset()         { *m = Anchor{} }
func (m *Anchor) String() string { return proto.CompactTextString(m) }
func (*Anchor) ProtoMessage()    {}
func (*Anchor) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{0}
}
func (m *Anchor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Anchor.Unmarshal(m, b)
}
func (m *Anchor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Anchor.Marshal(b, m, deterministic)
}
func (dst *Anchor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Anchor.Merge(dst, src)
}
func (m *Anchor) XXX_Size() int {
	return xxx_messageInfo_Anchor.Size(m)
}
func (m *Anchor) XXX_DiscardUnknown() {
	xxx_messageInfo_Anchor.DiscardUnknown(m)
}

var xxx_messageInfo_Anchor proto.InternalMessageInfo

func (m *Anchor) GetType() Anchor_Type {
	if m != nil {
		return m.Type
	}
	return Anchor_ETH
}

func (m *Anchor) GetStatus() Anchor_Status {
	if m != nil {
		return m.Status
	}
	return Anchor_ERROR
}

func (m *Anchor) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Anchor) GetSupportedFormats() []Proof_Format {
	if m != nil {
		return m.SupportedFormats
	}
	return nil
}

// Batch represents a batch of hashes. When hash stream comes in, Anchor Service
// will try to process them in batches, just like Blockchain processes
// transactions in blocks. This makes utilization of expensive resources, such
// as making Bitcoin transaction, more economic. Each batch's root hash will be
// embedded in a transaction made to the Blockchain
type Batch struct {
	// Id is the batch ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// AnchorType is the batch's anchor type
	AnchorType Anchor_Type `protobuf:"varint,2,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// ProofFormat is the batch's proof format, which determines how the merkle
	// tree is constructed for the batch.
	ProofFormat Proof_Format `protobuf:"varint,3,opt,name=proof_format,json=proofFormat,proto3,enum=anchor.Proof_Format" json:"proof_format,omitempty"`
	// Status is the batch status. FLOW: created_at -> BATCHING -> flushed_at ->
	// QUEUING -> started_at -> PROCESSING -> submitted_at -> PENDING ->
	// finalized_at -> CONFIRMED / ERROR; * -> ERROR; if a batch has not yet
	// reached PENDING and its anchor has restarted, the batch will be put back to
	// QUEUING
	Status Batch_Status `protobuf:"varint,4,opt,name=status,proto3,enum=anchor.Batch_Status" json:"status,omitempty"`
	// Error is the error message when status is ERROR
	Error string `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
	// Size is the number of hashes contained in the batch
	Size int64 `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	// CreateAt is the batch's created at timestamp. FLOW: created_at -> BATCHING
	CreatedAt *timestamp.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// FlushedAt is the batch's flushed at timestamp. FLOW: BATCHING -> flushed_at
	// -> QUEUING
	FlushedAt *timestamp.Timestamp `protobuf:"bytes,8,opt,name=flushed_at,json=flushedAt,proto3" json:"flushed_at,omitempty"`
	// StartedAt is the batch's started at timestamp. FLOW: QUEUING -> started_at
	// -> PROCESSING
	StartedAt *timestamp.Timestamp `protobuf:"bytes,9,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// SubmittedAt is the batch's submitted at timestamp. FLOW: PROCESSING ->
	// submitted_at -> PENDING
	SubmittedAt *timestamp.Timestamp `protobuf:"bytes,10,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
	// FinalizedAt is the batch's finalized at timestamp. FLOW: * -> finalized_at
	// -> CONFIRMED / ERROR. NOTE: this is not the real block confirmed time, use
	// the timestamp in the batch data instead
	FinalizedAt *timestamp.Timestamp `protobuf:"bytes,11,opt,name=finalized_at,json=finalizedAt,proto3" json:"finalized_at,omitempty"`
	// Hash is the batch's root hash
	Hash string `protobuf:"bytes,12,opt,name=hash,proto3" json:"hash,omitempty"`
	// Data is the batch data in JSON
	Data                 string   `protobuf:"bytes,13,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Batch) Reset()         { *m = Batch{} }
func (m *Batch) String() string { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()    {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{1}
}
func (m *Batch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Batch.Unmarshal(m, b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
}
func (dst *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(dst, src)
}
func (m *Batch) XXX_Size() int {
	return xxx_messageInfo_Batch.Size(m)
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

func (m *Batch) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Batch) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *Batch) GetProofFormat() Proof_Format {
	if m != nil {
		return m.ProofFormat
	}
	return Proof_CHP_PATH
}

func (m *Batch) GetStatus() Batch_Status {
	if m != nil {
		return m.Status
	}
	return Batch_ERROR
}

func (m *Batch) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Batch) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Batch) GetCreatedAt() *timestamp.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Batch) GetFlushedAt() *timestamp.Timestamp {
	if m != nil {
		return m.FlushedAt
	}
	return nil
}

func (m *Batch) GetStartedAt() *timestamp.Timestamp {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *Batch) GetSubmittedAt() *timestamp.Timestamp {
	if m != nil {
		return m.SubmittedAt
	}
	return nil
}

func (m *Batch) GetFinalizedAt() *timestamp.Timestamp {
	if m != nil {
		return m.FinalizedAt
	}
	return nil
}

func (m *Batch) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Batch) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// Proof represents a Blockchain proof of a hash, which is a Merkle path from
// the hash to the root hash of the proof's batch
type Proof struct {
	// Hash is the hash the proof is proving for
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// BatchId is the proof's batch ID
	BatchId string `protobuf:"bytes,2,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// AnchorType is the proof's anchor type
	AnchorType Anchor_Type `protobuf:"varint,3,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// BatchStatus is the proof's batch status
	BatchStatus Batch_Status `protobuf:"varint,4,opt,name=batch_status,json=batchStatus,proto3,enum=anchor.Batch_Status" json:"batch_status,omitempty"`
	// Format is the proof format
	Format Proof_Format `protobuf:"varint,5,opt,name=format,proto3,enum=anchor.Proof_Format" json:"format,omitempty"`
	// Data is the proof data in base64
	Data string `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// Batch is the proof's batch detail
	Batch                *Batch   `protobuf:"bytes,7,opt,name=batch,proto3" json:"batch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Proof) Reset()         { *m = Proof{} }
func (m *Proof) String() string { return proto.CompactTextString(m) }
func (*Proof) ProtoMessage()    {}
func (*Proof) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{2}
}
func (m *Proof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Proof.Unmarshal(m, b)
}
func (m *Proof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Proof.Marshal(b, m, deterministic)
}
func (dst *Proof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proof.Merge(dst, src)
}
func (m *Proof) XXX_Size() int {
	return xxx_messageInfo_Proof.Size(m)
}
func (m *Proof) XXX_DiscardUnknown() {
	xxx_messageInfo_Proof.DiscardUnknown(m)
}

var xxx_messageInfo_Proof proto.InternalMessageInfo

func (m *Proof) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Proof) GetBatchId() string {
	if m != nil {
		return m.BatchId
	}
	return ""
}

func (m *Proof) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *Proof) GetBatchStatus() Batch_Status {
	if m != nil {
		return m.BatchStatus
	}
	return Batch_ERROR
}

func (m *Proof) GetFormat() Proof_Format {
	if m != nil {
		return m.Format
	}
	return Proof_CHP_PATH
}

func (m *Proof) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Proof) GetBatch() *Batch {
	if m != nil {
		return m.Batch
	}
	return nil
}

// AnchorRequest represents a request to get information for the given anchor
// type
type AnchorRequest struct {
	// Type is the anchor type
	Type                 Anchor_Type `protobuf:"varint,1,opt,name=type,proto3,enum=anchor.Anchor_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AnchorRequest) Reset()         { *m = AnchorRequest{} }
func (m *AnchorRequest) String() string { return proto.CompactTextString(m) }
func (*AnchorRequest) ProtoMessage()    {}
func (*AnchorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{3}
}
func (m *AnchorRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnchorRequest.Unmarshal(m, b)
}
func (m *AnchorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnchorRequest.Marshal(b, m, deterministic)
}
func (dst *AnchorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorRequest.Merge(dst, src)
}
func (m *AnchorRequest) XXX_Size() int {
	return xxx_messageInfo_AnchorRequest.Size(m)
}
func (m *AnchorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorRequest proto.InternalMessageInfo

func (m *AnchorRequest) GetType() Anchor_Type {
	if m != nil {
		return m.Type
	}
	return Anchor_ETH
}

// ProofRequest represents a proof request
type ProofRequest struct {
	// Hash is the hash the proof is proving for
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// BatchId is the proof's batch ID
	BatchId string `protobuf:"bytes,2,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// AnchorType is the proof's anchor type
	AnchorType Anchor_Type `protobuf:"varint,3,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// WithBatch indicates whether to include the proof's batch detail
	WithBatch            bool     `protobuf:"varint,4,opt,name=with_batch,json=withBatch,proto3" json:"with_batch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProofRequest) Reset()         { *m = ProofRequest{} }
func (m *ProofRequest) String() string { return proto.CompactTextString(m) }
func (*ProofRequest) ProtoMessage()    {}
func (*ProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{4}
}
func (m *ProofRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProofRequest.Unmarshal(m, b)
}
func (m *ProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProofRequest.Marshal(b, m, deterministic)
}
func (dst *ProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofRequest.Merge(dst, src)
}
func (m *ProofRequest) XXX_Size() int {
	return xxx_messageInfo_ProofRequest.Size(m)
}
func (m *ProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProofRequest proto.InternalMessageInfo

func (m *ProofRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ProofRequest) GetBatchId() string {
	if m != nil {
		return m.BatchId
	}
	return ""
}

func (m *ProofRequest) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *ProofRequest) GetWithBatch() bool {
	if m != nil {
		return m.WithBatch
	}
	return false
}

// SubmitProofRequest represents a submit proof request
type SubmitProofRequest struct {
	// Hash is the hash to be submitted
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// AnchorType is the anchor type to be used
	AnchorType Anchor_Type `protobuf:"varint,2,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// Format is the proof format to be used
	Format Proof_Format `protobuf:"varint,3,opt,name=format,proto3,enum=anchor.Proof_Format" json:"format,omitempty"`
	// SkipBatching indicates whether to skip batching and submit a proof for the
	// hash directly
	SkipBatching bool `protobuf:"varint,4,opt,name=skip_batching,json=skipBatching,proto3" json:"skip_batching,omitempty"`
	// WithBatch indicates whether to include the batch detail in the reply
	WithBatch            bool     `protobuf:"varint,5,opt,name=with_batch,json=withBatch,proto3" json:"with_batch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmitProofRequest) Reset()         { *m = SubmitProofRequest{} }
func (m *SubmitProofRequest) String() string { return proto.CompactTextString(m) }
func (*SubmitProofRequest) ProtoMessage()    {}
func (*SubmitProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{5}
}
func (m *SubmitProofRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubmitProofRequest.Unmarshal(m, b)
}
func (m *SubmitProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubmitProofRequest.Marshal(b, m, deterministic)
}
func (dst *SubmitProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitProofRequest.Merge(dst, src)
}
func (m *SubmitProofRequest) XXX_Size() int {
	return xxx_messageInfo_SubmitProofRequest.Size(m)
}
func (m *SubmitProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitProofRequest proto.InternalMessageInfo

func (m *SubmitProofRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *SubmitProofRequest) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *SubmitProofRequest) GetFormat() Proof_Format {
	if m != nil {
		return m.Format
	}
	return Proof_CHP_PATH
}

func (m *SubmitProofRequest) GetSkipBatching() bool {
	if m != nil {
		return m.SkipBatching
	}
	return false
}

func (m *SubmitProofRequest) GetWithBatch() bool {
	if m != nil {
		return m.WithBatch
	}
	return false
}

// VerifyProofRequest represents a verify proof request
type VerifyProofRequest struct {
	// AnchorType is the proof's anchor type
	AnchorType Anchor_Type `protobuf:"varint,1,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// Format is the proof format. If skipping the signature checking is desired,
	// please use the corresponding non-signed format, eg. use CHP_PATH instead of
	// CHP_PATH_SIGNED in request
	Format Proof_Format `protobuf:"varint,2,opt,name=format,proto3,enum=anchor.Proof_Format" json:"format,omitempty"`
	// Data is the proof data in base64
	Data                 string   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyProofRequest) Reset()         { *m = VerifyProofRequest{} }
func (m *VerifyProofRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyProofRequest) ProtoMessage()    {}
func (*VerifyProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{6}
}
func (m *VerifyProofRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VerifyProofRequest.Unmarshal(m, b)
}
func (m *VerifyProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VerifyProofRequest.Marshal(b, m, deterministic)
}
func (dst *VerifyProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyProofRequest.Merge(dst, src)
}
func (m *VerifyProofRequest) XXX_Size() int {
	return xxx_messageInfo_VerifyProofRequest.Size(m)
}
func (m *VerifyProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyProofRequest proto.InternalMessageInfo

func (m *VerifyProofRequest) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *VerifyProofRequest) GetFormat() Proof_Format {
	if m != nil {
		return m.Format
	}
	return Proof_CHP_PATH
}

func (m *VerifyProofRequest) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// VerifyProofReply represents a verify proof reply
type VerifyProofReply struct {
	// Verified indicates whether the proof is verified
	Verified bool `protobuf:"varint,1,opt,name=verified,proto3" json:"verified,omitempty"`
	// Erorr is the error message when the proof is falsified
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// ProvenHash is the hash the proof is proving for
	ProvenHash           string   `protobuf:"bytes,3,opt,name=provenHash,proto3" json:"provenHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyProofReply) Reset()         { *m = VerifyProofReply{} }
func (m *VerifyProofReply) String() string { return proto.CompactTextString(m) }
func (*VerifyProofReply) ProtoMessage()    {}
func (*VerifyProofReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{7}
}
func (m *VerifyProofReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VerifyProofReply.Unmarshal(m, b)
}
func (m *VerifyProofReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VerifyProofReply.Marshal(b, m, deterministic)
}
func (dst *VerifyProofReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyProofReply.Merge(dst, src)
}
func (m *VerifyProofReply) XXX_Size() int {
	return xxx_messageInfo_VerifyProofReply.Size(m)
}
func (m *VerifyProofReply) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyProofReply.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyProofReply proto.InternalMessageInfo

func (m *VerifyProofReply) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

func (m *VerifyProofReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *VerifyProofReply) GetProvenHash() string {
	if m != nil {
		return m.ProvenHash
	}
	return ""
}

// BatchRequest represents a batch request
type BatchRequest struct {
	// BatchId is the batch ID
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// AnchorType is the batch's anchor type
	AnchorType           Anchor_Type `protobuf:"varint,2,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BatchRequest) Reset()         { *m = BatchRequest{} }
func (m *BatchRequest) String() string { return proto.CompactTextString(m) }
func (*BatchRequest) ProtoMessage()    {}
func (*BatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{8}
}
func (m *BatchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchRequest.Unmarshal(m, b)
}
func (m *BatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchRequest.Marshal(b, m, deterministic)
}
func (dst *BatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchRequest.Merge(dst, src)
}
func (m *BatchRequest) XXX_Size() int {
	return xxx_messageInfo_BatchRequest.Size(m)
}
func (m *BatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchRequest proto.InternalMessageInfo

func (m *BatchRequest) GetBatchId() string {
	if m != nil {
		return m.BatchId
	}
	return ""
}

func (m *BatchRequest) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

// SubscribeBatchesRequest represents a subscription request for batch
// information
type SubscribeBatchesRequest struct {
	// Filter is the batch filter. When nil, all batches of all anchors will be
	// subscribed; otherwise, only the batches of the given anchor will be
	// subscribed; if batch_id is non-empty, only the matched batch will be
	// subscribed
	Filter               *BatchRequest `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SubscribeBatchesRequest) Reset()         { *m = SubscribeBatchesRequest{} }
func (m *SubscribeBatchesRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeBatchesRequest) ProtoMessage()    {}
func (*SubscribeBatchesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_526f30b8e2265be6, []int{9}
}
func (m *SubscribeBatchesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeBatchesRequest.Unmarshal(m, b)
}
func (m *SubscribeBatchesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeBatchesRequest.Marshal(b, m, deterministic)
}
func (dst *SubscribeBatchesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeBatchesRequest.Merge(dst, src)
}
func (m *SubscribeBatchesRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeBatchesRequest.Size(m)
}
func (m *SubscribeBatchesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeBatchesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeBatchesRequest proto.InternalMessageInfo

func (m *SubscribeBatchesRequest) GetFilter() *BatchRequest {
	if m != nil {
		return m.Filter
	}
	return nil
}

func init() {
	proto.RegisterType((*Anchor)(nil), "anchor.Anchor")
	proto.RegisterType((*Batch)(nil), "anchor.Batch")
	proto.RegisterType((*Proof)(nil), "anchor.Proof")
	proto.RegisterType((*AnchorRequest)(nil), "anchor.AnchorRequest")
	proto.RegisterType((*ProofRequest)(nil), "anchor.ProofRequest")
	proto.RegisterType((*SubmitProofRequest)(nil), "anchor.SubmitProofRequest")
	proto.RegisterType((*VerifyProofRequest)(nil), "anchor.VerifyProofRequest")
	proto.RegisterType((*VerifyProofReply)(nil), "anchor.VerifyProofReply")
	proto.RegisterType((*BatchRequest)(nil), "anchor.BatchRequest")
	proto.RegisterType((*SubscribeBatchesRequest)(nil), "anchor.SubscribeBatchesRequest")
	proto.RegisterEnum("anchor.Anchor_Type", Anchor_Type_name, Anchor_Type_value)
	proto.RegisterEnum("anchor.Anchor_Status", Anchor_Status_name, Anchor_Status_value)
	proto.RegisterEnum("anchor.Batch_Status", Batch_Status_name, Batch_Status_value)
	proto.RegisterEnum("anchor.Proof_Format", Proof_Format_name, Proof_Format_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AnchorServiceClient is the client API for AnchorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AnchorServiceClient interface {
	// GetAnchors gets all anchors
	GetAnchors(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (AnchorService_GetAnchorsClient, error)
	// GetAnchor gets an anchor
	GetAnchor(ctx context.Context, in *AnchorRequest, opts ...grpc.CallOption) (*Anchor, error)
	// GetProof gets a proof
	GetProof(ctx context.Context, in *ProofRequest, opts ...grpc.CallOption) (*Proof, error)
	// SubmitProof submits a proof for the given hash
	SubmitProof(ctx context.Context, in *SubmitProofRequest, opts ...grpc.CallOption) (*Proof, error)
	// VerifyProof verifies the given proof. When the proof is unverifiable, an
	// exception is thrown
	VerifyProof(ctx context.Context, in *VerifyProofRequest, opts ...grpc.CallOption) (*VerifyProofReply, error)
	// GetBatch gets a batch
	GetBatch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*Batch, error)
	// SubscribeBatches subscribes to batch status updates
	SubscribeBatches(ctx context.Context, in *SubscribeBatchesRequest, opts ...grpc.CallOption) (AnchorService_SubscribeBatchesClient, error)
}

type anchorServiceClient struct {
	cc *grpc.ClientConn
}

func NewAnchorServiceClient(cc *grpc.ClientConn) AnchorServiceClient {
	return &anchorServiceClient{cc}
}

func (c *anchorServiceClient) GetAnchors(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (AnchorService_GetAnchorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AnchorService_serviceDesc.Streams[0], "/anchor.AnchorService/GetAnchors", opts...)
	if err != nil {
		return nil, err
	}
	x := &anchorServiceGetAnchorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AnchorService_GetAnchorsClient interface {
	Recv() (*Anchor, error)
	grpc.ClientStream
}

type anchorServiceGetAnchorsClient struct {
	grpc.ClientStream
}

func (x *anchorServiceGetAnchorsClient) Recv() (*Anchor, error) {
	m := new(Anchor)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *anchorServiceClient) GetAnchor(ctx context.Context, in *AnchorRequest, opts ...grpc.CallOption) (*Anchor, error) {
	out := new(Anchor)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/GetAnchor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) GetProof(ctx context.Context, in *ProofRequest, opts ...grpc.CallOption) (*Proof, error) {
	out := new(Proof)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/GetProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) SubmitProof(ctx context.Context, in *SubmitProofRequest, opts ...grpc.CallOption) (*Proof, error) {
	out := new(Proof)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/SubmitProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) VerifyProof(ctx context.Context, in *VerifyProofRequest, opts ...grpc.CallOption) (*VerifyProofReply, error) {
	out := new(VerifyProofReply)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/VerifyProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) GetBatch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*Batch, error) {
	out := new(Batch)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/GetBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) SubscribeBatches(ctx context.Context, in *SubscribeBatchesRequest, opts ...grpc.CallOption) (AnchorService_SubscribeBatchesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AnchorService_serviceDesc.Streams[1], "/anchor.AnchorService/SubscribeBatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &anchorServiceSubscribeBatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AnchorService_SubscribeBatchesClient interface {
	Recv() (*Batch, error)
	grpc.ClientStream
}

type anchorServiceSubscribeBatchesClient struct {
	grpc.ClientStream
}

func (x *anchorServiceSubscribeBatchesClient) Recv() (*Batch, error) {
	m := new(Batch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AnchorServiceServer is the server API for AnchorService service.
type AnchorServiceServer interface {
	// GetAnchors gets all anchors
	GetAnchors(*empty.Empty, AnchorService_GetAnchorsServer) error
	// GetAnchor gets an anchor
	GetAnchor(context.Context, *AnchorRequest) (*Anchor, error)
	// GetProof gets a proof
	GetProof(context.Context, *ProofRequest) (*Proof, error)
	// SubmitProof submits a proof for the given hash
	SubmitProof(context.Context, *SubmitProofRequest) (*Proof, error)
	// VerifyProof verifies the given proof. When the proof is unverifiable, an
	// exception is thrown
	VerifyProof(context.Context, *VerifyProofRequest) (*VerifyProofReply, error)
	// GetBatch gets a batch
	GetBatch(context.Context, *BatchRequest) (*Batch, error)
	// SubscribeBatches subscribes to batch status updates
	SubscribeBatches(*SubscribeBatchesRequest, AnchorService_SubscribeBatchesServer) error
}

func RegisterAnchorServiceServer(s *grpc.Server, srv AnchorServiceServer) {
	s.RegisterService(&_AnchorService_serviceDesc, srv)
}

func _AnchorService_GetAnchors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AnchorServiceServer).GetAnchors(m, &anchorServiceGetAnchorsServer{stream})
}

type AnchorService_GetAnchorsServer interface {
	Send(*Anchor) error
	grpc.ServerStream
}

type anchorServiceGetAnchorsServer struct {
	grpc.ServerStream
}

func (x *anchorServiceGetAnchorsServer) Send(m *Anchor) error {
	return x.ServerStream.SendMsg(m)
}

func _AnchorService_GetAnchor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).GetAnchor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/GetAnchor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).GetAnchor(ctx, req.(*AnchorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_GetProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).GetProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/GetProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).GetProof(ctx, req.(*ProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_SubmitProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).SubmitProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/SubmitProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).SubmitProof(ctx, req.(*SubmitProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_VerifyProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).VerifyProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/VerifyProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).VerifyProof(ctx, req.(*VerifyProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_GetBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).GetBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/GetBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).GetBatch(ctx, req.(*BatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_SubscribeBatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeBatchesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AnchorServiceServer).SubscribeBatches(m, &anchorServiceSubscribeBatchesServer{stream})
}

type AnchorService_SubscribeBatchesServer interface {
	Send(*Batch) error
	grpc.ServerStream
}

type anchorServiceSubscribeBatchesServer struct {
	grpc.ServerStream
}

func (x *anchorServiceSubscribeBatchesServer) Send(m *Batch) error {
	return x.ServerStream.SendMsg(m)
}

var _AnchorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "anchor.AnchorService",
	HandlerType: (*AnchorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAnchor",
			Handler:    _AnchorService_GetAnchor_Handler,
		},
		{
			MethodName: "GetProof",
			Handler:    _AnchorService_GetProof_Handler,
		},
		{
			MethodName: "SubmitProof",
			Handler:    _AnchorService_SubmitProof_Handler,
		},
		{
			MethodName: "VerifyProof",
			Handler:    _AnchorService_VerifyProof_Handler,
		},
		{
			MethodName: "GetBatch",
			Handler:    _AnchorService_GetBatch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAnchors",
			Handler:       _AnchorService_GetAnchors_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeBatches",
			Handler:       _AnchorService_SubscribeBatches_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "anchor/anchor.proto",
}

func init() { proto.RegisterFile("anchor/anchor.proto", fileDescriptor_anchor_526f30b8e2265be6) }

var fileDescriptor_anchor_526f30b8e2265be6 = []byte{
	// 1060 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xdd, 0x72, 0xdb, 0x44,
	0x14, 0x8e, 0x24, 0xcb, 0xb1, 0x8f, 0xec, 0x54, 0x6c, 0x0a, 0xb8, 0x66, 0xa0, 0x19, 0xf5, 0x82,
	0x5c, 0xb4, 0x4e, 0x09, 0x9d, 0x21, 0x30, 0xc3, 0x85, 0xed, 0x28, 0xb1, 0x67, 0xa8, 0x23, 0x56,
	0x0a, 0x17, 0xbd, 0xf1, 0x48, 0xf6, 0x3a, 0x16, 0xb1, 0x23, 0x21, 0xad, 0xd3, 0x71, 0x9f, 0x81,
	0x1b, 0x78, 0x04, 0x9e, 0x80, 0x27, 0xe0, 0x19, 0x78, 0x00, 0x1e, 0x86, 0xd9, 0x1f, 0x29, 0xb2,
	0x9d, 0x34, 0x29, 0x17, 0x5c, 0x59, 0xe7, 0x9c, 0xef, 0xdb, 0x3d, 0x3f, 0xdf, 0xae, 0x17, 0x76,
	0xfd, 0xab, 0xd1, 0x34, 0x4a, 0x0e, 0xc4, 0x4f, 0x2b, 0x4e, 0x22, 0x1a, 0xa1, 0xb2, 0xb0, 0x9a,
	0x9f, 0x5d, 0x44, 0xd1, 0xc5, 0x8c, 0x1c, 0x70, 0x6f, 0xb0, 0x98, 0x1c, 0x90, 0x79, 0x4c, 0x97,
	0x02, 0xd4, 0x7c, 0xba, 0x1e, 0xa4, 0xe1, 0x9c, 0xa4, 0xd4, 0x9f, 0xc7, 0x02, 0x60, 0xfd, 0xa5,
	0x42, 0xb9, 0xcd, 0x17, 0x42, 0x5f, 0x42, 0x89, 0x2e, 0x63, 0xd2, 0x50, 0xf6, 0x94, 0xfd, 0x9d,
	0xc3, 0xdd, 0x96, 0xdc, 0x4d, 0x44, 0x5b, 0xde, 0x32, 0x26, 0x98, 0x03, 0xd0, 0x0b, 0x28, 0xa7,
	0xd4, 0xa7, 0x8b, 0xb4, 0xa1, 0x72, 0xe8, 0xc7, 0x6b, 0x50, 0x97, 0x07, 0xb1, 0x04, 0xa1, 0xc7,
	0xa0, 0x93, 0x24, 0x89, 0x92, 0x86, 0xb6, 0xa7, 0xec, 0x57, 0xb1, 0x30, 0x50, 0x1b, 0x3e, 0x4a,
	0x17, 0x71, 0x1c, 0x25, 0x94, 0x8c, 0x87, 0x93, 0x28, 0x99, 0xfb, 0x34, 0x6d, 0x94, 0xf6, 0xb4,
	0xfd, 0x9d, 0xc3, 0xc7, 0xd9, 0x7a, 0x4e, 0x12, 0x45, 0x93, 0xd6, 0x09, 0x0f, 0x62, 0x33, 0x87,
	0x0b, 0x47, 0x6a, 0x79, 0x50, 0x62, 0x59, 0xa1, 0x6d, 0xd0, 0x6c, 0xaf, 0x67, 0x6e, 0xa1, 0x47,
	0x60, 0xd8, 0x5e, 0x6f, 0xf8, 0xba, 0xdd, 0x1f, 0x0c, 0x6c, 0xcf, 0xd4, 0x32, 0x87, 0xfd, 0x43,
	0xdb, 0xf5, 0xce, 0x5c, 0xb3, 0xc4, 0xa0, 0x1d, 0xaf, 0x6b, 0x2a, 0x2c, 0xd2, 0xf1, 0xba, 0x39,
	0x54, 0x67, 0x91, 0x6e, 0xcf, 0x31, 0x55, 0xeb, 0x05, 0x94, 0x45, 0x01, 0xa8, 0x0a, 0xba, 0x8d,
	0xf1, 0x19, 0x36, 0xb7, 0x90, 0x01, 0xdb, 0xae, 0x77, 0xe6, 0x38, 0xf6, 0xb1, 0xa9, 0x30, 0x03,
	0x9f, 0x0f, 0x06, 0xfd, 0xc1, 0xa9, 0xa9, 0x5a, 0xbf, 0xe9, 0xa0, 0x77, 0x7c, 0x3a, 0x9a, 0xa2,
	0x1d, 0x50, 0xc3, 0x31, 0xef, 0x5e, 0x15, 0xab, 0xe1, 0x18, 0xbd, 0x02, 0x43, 0xd4, 0x31, 0xe4,
	0x6d, 0x55, 0xef, 0x6e, 0x2b, 0x08, 0x1f, 0x2f, 0xe6, 0x1b, 0xa8, 0xc5, 0xac, 0x6c, 0xd9, 0x13,
	0xde, 0xb4, 0xbb, 0x5a, 0x62, 0x70, 0xa4, 0x30, 0xd0, 0xf3, 0x7c, 0x2a, 0xa5, 0x55, 0x0a, 0xcf,
	0xee, 0xce, 0xa1, 0xe8, 0xc5, 0xa1, 0x20, 0x28, 0xa5, 0xe1, 0x3b, 0xd2, 0x28, 0xef, 0x29, 0xfb,
	0x1a, 0xe6, 0xdf, 0xe8, 0x5b, 0x80, 0x51, 0x42, 0x7c, 0x36, 0x26, 0x9f, 0x36, 0xb6, 0xf7, 0x94,
	0x7d, 0xe3, 0xb0, 0xd9, 0x12, 0xba, 0x6a, 0x65, 0xba, 0x6a, 0x79, 0x99, 0xae, 0x70, 0x55, 0xa2,
	0xdb, 0x94, 0x51, 0x27, 0xb3, 0x45, 0x3a, 0x15, 0xd4, 0xca, 0xfd, 0x54, 0x89, 0x16, 0xd4, 0x94,
	0xfa, 0x89, 0xdc, 0xb5, 0x7a, 0x3f, 0x55, 0xa2, 0xdb, 0x14, 0x7d, 0x0f, 0xb5, 0x74, 0x11, 0xcc,
	0x43, 0x2a, 0xc9, 0x70, 0x2f, 0xd9, 0xc8, 0xf1, 0x82, 0x3e, 0x09, 0xaf, 0xfc, 0x59, 0xf8, 0x4e,
	0xd0, 0x8d, 0xfb, 0xe9, 0x39, 0xbe, 0x4d, 0x59, 0x0b, 0xa7, 0x7e, 0x3a, 0x6d, 0xd4, 0x78, 0x5f,
	0xf9, 0x37, 0xf3, 0x8d, 0x7d, 0xea, 0x37, 0xea, 0xc2, 0xc7, 0xbe, 0xad, 0x37, 0xb7, 0xc9, 0xac,
	0x06, 0x95, 0x4e, 0xdb, 0xeb, 0xf6, 0x98, 0xb4, 0xb8, 0xce, 0x7e, 0x3c, 0xb7, 0xcf, 0xb9, 0xce,
	0xd0, 0x0e, 0x80, 0x83, 0xcf, 0xba, 0xb6, 0xeb, 0x32, 0x5b, 0x63, 0x41, 0xc7, 0x1e, 0x1c, 0x33,
	0xa3, 0x84, 0xea, 0x50, 0xed, 0x9e, 0x0d, 0x4e, 0xfa, 0xf8, 0xb5, 0x7d, 0x6c, 0xea, 0xd6, 0x3f,
	0x2a, 0xe8, 0x5c, 0x28, 0x79, 0x36, 0x4a, 0x21, 0x9b, 0x27, 0x50, 0x09, 0x98, 0x24, 0x86, 0xe1,
	0x98, 0x8b, 0xb2, 0x8a, 0xb7, 0xb9, 0xdd, 0xdf, 0x90, 0xac, 0xf6, 0x60, 0xc9, 0x8a, 0x05, 0x1f,
	0xa0, 0x3f, 0x83, 0x23, 0x65, 0xe5, 0xcf, 0xa1, 0x2c, 0x55, 0xae, 0xbf, 0x47, 0xe5, 0x12, 0x93,
	0x77, 0xb1, 0x7c, 0xd3, 0x45, 0xf4, 0x0c, 0x74, 0xbe, 0xa0, 0xd4, 0x65, 0x7d, 0x65, 0x4f, 0x2c,
	0x62, 0xd6, 0x00, 0xca, 0xf2, 0x8c, 0xd4, 0xa0, 0xd2, 0xed, 0x39, 0x43, 0xa7, 0xcd, 0xaf, 0x8b,
	0x1a, 0x54, 0xd8, 0xed, 0xe0, 0xe1, 0xbe, 0x6d, 0x2a, 0x68, 0x17, 0x1e, 0x65, 0xb1, 0xa1, 0xdb,
	0x3f, 0x1d, 0xd8, 0xc7, 0xa6, 0xca, 0x9c, 0x19, 0x24, 0x73, 0x6a, 0xd6, 0x11, 0xd4, 0x45, 0x2b,
	0x30, 0xf9, 0x65, 0x41, 0x52, 0xfa, 0xe0, 0x9b, 0xd3, 0xfa, 0x5d, 0x81, 0x1a, 0xaf, 0x2d, 0x63,
	0xfe, 0x2f, 0xf3, 0xf9, 0x1c, 0xe0, 0x6d, 0x48, 0xa7, 0x43, 0xd1, 0x29, 0x36, 0x9d, 0x0a, 0xae,
	0x32, 0x0f, 0xef, 0x92, 0xf5, 0xb7, 0x02, 0xc8, 0xe5, 0x07, 0xe0, 0xde, 0xd4, 0xfe, 0xdb, 0x95,
	0x76, 0x33, 0x66, 0xed, 0x01, 0x63, 0x7e, 0x06, 0xf5, 0xf4, 0x32, 0x8c, 0x45, 0xb6, 0xe1, 0xd5,
	0x85, 0x4c, 0xb8, 0xc6, 0x9c, 0x1d, 0xe9, 0x5b, 0x2b, 0x49, 0x5f, 0x2f, 0xe9, 0x57, 0x05, 0xd0,
	0x4f, 0x24, 0x09, 0x27, 0xcb, 0x95, 0x92, 0xd6, 0xd2, 0x57, 0x3e, 0x34, 0x7d, 0xf5, 0x03, 0x54,
	0xaa, 0x15, 0xce, 0xfa, 0x18, 0xcc, 0x95, 0x6c, 0xe2, 0xd9, 0x12, 0x35, 0xa1, 0x72, 0xcd, 0x7c,
	0x21, 0x11, 0xff, 0x19, 0x15, 0x9c, 0xdb, 0x37, 0x97, 0xb3, 0x5a, 0xbc, 0x9c, 0xbf, 0x00, 0x88,
	0x93, 0xe8, 0x9a, 0x5c, 0xf5, 0xd8, 0x58, 0xc4, 0xfa, 0x05, 0x8f, 0x35, 0x84, 0x9a, 0x90, 0xbd,
	0xac, 0xb6, 0xa8, 0x23, 0xe5, 0xbd, 0x3a, 0x7a, 0xd8, 0x1c, 0xad, 0x53, 0xf8, 0xd4, 0x5d, 0x04,
	0xe9, 0x28, 0x09, 0x03, 0xc2, 0x77, 0x22, 0x69, 0xb6, 0x17, 0xeb, 0x51, 0x38, 0xa3, 0x24, 0xe1,
	0x3b, 0x19, 0x6b, 0x87, 0x5f, 0xa2, 0xb0, 0xc4, 0x1c, 0xfe, 0xa9, 0x65, 0x27, 0xc8, 0x25, 0xc9,
	0x75, 0x38, 0x22, 0xe8, 0x08, 0xe0, 0x94, 0x50, 0xe1, 0x4b, 0xd1, 0x27, 0x1b, 0x97, 0xad, 0xcd,
	0xde, 0x34, 0xcd, 0x9d, 0xd5, 0x0c, 0xad, 0xad, 0x97, 0x0a, 0x7a, 0x05, 0xd5, 0x9c, 0x89, 0xd6,
	0x5e, 0x22, 0x72, 0xdf, 0x4d, 0x1e, 0xfa, 0x0a, 0x2a, 0xa7, 0x44, 0xe8, 0x1d, 0xad, 0xce, 0x33,
	0xe3, 0xd4, 0x57, 0xbc, 0xd6, 0x16, 0xfa, 0x0e, 0x8c, 0xc2, 0x29, 0x41, 0xcd, 0x2c, 0xbe, 0x79,
	0x74, 0x36, 0xb9, 0x36, 0x18, 0x05, 0x01, 0xdc, 0x70, 0x37, 0x35, 0xda, 0x6c, 0xdc, 0x1a, 0x8b,
	0x67, 0xcb, 0x3c, 0x6b, 0xf1, 0xda, 0xb8, 0xb5, 0xc3, 0xcd, 0xd5, 0x0b, 0xd0, 0xda, 0x42, 0x27,
	0x60, 0xae, 0xcf, 0x0c, 0x3d, 0x2d, 0xa4, 0x7e, 0xdb, 0x34, 0x37, 0x56, 0x79, 0xa9, 0x74, 0x7e,
	0x86, 0x27, 0xa3, 0x68, 0xde, 0x12, 0x72, 0x1b, 0x07, 0xad, 0xe2, 0x53, 0xb4, 0x63, 0x88, 0xbe,
	0x3a, 0xcc, 0x70, 0x94, 0x37, 0x47, 0x17, 0x21, 0x9d, 0x2e, 0x82, 0xd6, 0x28, 0x9a, 0x1f, 0xb8,
	0xd1, 0x82, 0x4e, 0x03, 0xff, 0xea, 0xd2, 0x8d, 0x26, 0xf4, 0xad, 0x9f, 0xf0, 0xa7, 0x68, 0x34,
	0xf1, 0x03, 0xf6, 0x28, 0xbd, 0xbc, 0x10, 0x0f, 0xd3, 0x54, 0xbe, 0x6c, 0xff, 0x50, 0xb5, 0x76,
	0xb7, 0x17, 0x94, 0xb9, 0xf3, 0xeb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x4e, 0xa1, 0xc6, 0x45,
	0xf7, 0x0a, 0x00, 0x00,
}
