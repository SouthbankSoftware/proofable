// Code generated by protoc-gen-go. DO NOT EDIT.
// source: anchor/anchor.proto

package anchor // import "github.com/SouthbankSoftware/provenx-cli/pkg/protos/anchor"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import empty "github.com/golang/protobuf/ptypes/empty"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Anchor_Type int32

const (
	// ethereum
	Anchor_ETH Anchor_Type = 0
	// ethereum mainnet
	Anchor_ETH_MAINNET Anchor_Type = 3
	// ethereum elastos
	Anchor_ETH_ELASTOS Anchor_Type = 4
	// bitcoin
	Anchor_BTC Anchor_Type = 1
	// bitcoin mainnet
	Anchor_BTC_MAINNET Anchor_Type = 5
	// chainpoint
	Anchor_CHP Anchor_Type = 2
)

var Anchor_Type_name = map[int32]string{
	0: "ETH",
	3: "ETH_MAINNET",
	4: "ETH_ELASTOS",
	1: "BTC",
	5: "BTC_MAINNET",
	2: "CHP",
}
var Anchor_Type_value = map[string]int32{
	"ETH":         0,
	"ETH_MAINNET": 3,
	"ETH_ELASTOS": 4,
	"BTC":         1,
	"BTC_MAINNET": 5,
	"CHP":         2,
}

func (x Anchor_Type) String() string {
	return proto.EnumName(Anchor_Type_name, int32(x))
}
func (Anchor_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{1, 0}
}

type Anchor_Status int32

const (
	// error
	Anchor_ERROR Anchor_Status = 0
	// stopped
	Anchor_STOPPED Anchor_Status = 1
	// running
	Anchor_RUNNING Anchor_Status = 2
)

var Anchor_Status_name = map[int32]string{
	0: "ERROR",
	1: "STOPPED",
	2: "RUNNING",
}
var Anchor_Status_value = map[string]int32{
	"ERROR":   0,
	"STOPPED": 1,
	"RUNNING": 2,
}

func (x Anchor_Status) String() string {
	return proto.EnumName(Anchor_Status_name, int32(x))
}
func (Anchor_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{1, 1}
}

type Batch_Status int32

const (
	// error. FLOW: * -> ERROR
	Batch_ERROR Batch_Status = 0
	// batching for more hashes. FLOW: created_at -> BATCHING -> flushed_at
	Batch_BATCHING Batch_Status = 1
	// queuing to be processed. FLOW: flushed_at -> QUEUING -> started_at
	Batch_QUEUING Batch_Status = 2
	// constructing the merkle roots and submitting hashes. FLOW: started_at ->
	// PROCESSING -> submitted_at
	Batch_PROCESSING Batch_Status = 3
	// batch root hash is pending to be confirmed. FLOW: submitted_at -> PENDING
	// -> finalized_at
	Batch_PENDING Batch_Status = 4
	// batch root hash is confirmed by the anchor. FLOW: finalized_at ->
	// CONFIRMED
	Batch_CONFIRMED Batch_Status = 5
)

var Batch_Status_name = map[int32]string{
	0: "ERROR",
	1: "BATCHING",
	2: "QUEUING",
	3: "PROCESSING",
	4: "PENDING",
	5: "CONFIRMED",
}
var Batch_Status_value = map[string]int32{
	"ERROR":      0,
	"BATCHING":   1,
	"QUEUING":    2,
	"PROCESSING": 3,
	"PENDING":    4,
	"CONFIRMED":  5,
}

func (x Batch_Status) String() string {
	return proto.EnumName(Batch_Status_name, int32(x))
}
func (Batch_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{5, 0}
}

type Proof_Format int32

const (
	// chainpoint path
	Proof_CHP_PATH Proof_Format = 0
	// ethereum trie
	Proof_ETH_TRIE Proof_Format = 1
	// signed chainpoint path
	Proof_CHP_PATH_SIGNED Proof_Format = 2
	// signed ethereum trie
	Proof_ETH_TRIE_SIGNED Proof_Format = 3
)

var Proof_Format_name = map[int32]string{
	0: "CHP_PATH",
	1: "ETH_TRIE",
	2: "CHP_PATH_SIGNED",
	3: "ETH_TRIE_SIGNED",
}
var Proof_Format_value = map[string]int32{
	"CHP_PATH":        0,
	"ETH_TRIE":        1,
	"CHP_PATH_SIGNED": 2,
	"ETH_TRIE_SIGNED": 3,
}

func (x Proof_Format) String() string {
	return proto.EnumName(Proof_Format_name, int32(x))
}
func (Proof_Format) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{7, 0}
}

// *
// Anchor request
type AnchorRequest struct {
	// anchor type
	Type                 Anchor_Type `protobuf:"varint,1,opt,name=type,proto3,enum=anchor.Anchor_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AnchorRequest) Reset()         { *m = AnchorRequest{} }
func (m *AnchorRequest) String() string { return proto.CompactTextString(m) }
func (*AnchorRequest) ProtoMessage()    {}
func (*AnchorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{0}
}
func (m *AnchorRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AnchorRequest.Unmarshal(m, b)
}
func (m *AnchorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AnchorRequest.Marshal(b, m, deterministic)
}
func (dst *AnchorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorRequest.Merge(dst, src)
}
func (m *AnchorRequest) XXX_Size() int {
	return xxx_messageInfo_AnchorRequest.Size(m)
}
func (m *AnchorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorRequest proto.InternalMessageInfo

func (m *AnchorRequest) GetType() Anchor_Type {
	if m != nil {
		return m.Type
	}
	return Anchor_ETH
}

// *
// Anchor detail
type Anchor struct {
	// anchor type
	Type Anchor_Type `protobuf:"varint,1,opt,name=type,proto3,enum=anchor.Anchor_Type" json:"type,omitempty"`
	// anchor status
	Status Anchor_Status `protobuf:"varint,2,opt,name=status,proto3,enum=anchor.Anchor_Status" json:"status,omitempty"`
	// the error message when status is ERROR
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	// supported proof formats
	SupportedFormats     []Proof_Format `protobuf:"varint,4,rep,packed,name=supported_formats,json=supportedFormats,proto3,enum=anchor.Proof_Format" json:"supported_formats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Anchor) Reset()         { *m = Anchor{} }
func (m *Anchor) String() string { return proto.CompactTextString(m) }
func (*Anchor) ProtoMessage()    {}
func (*Anchor) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{1}
}
func (m *Anchor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Anchor.Unmarshal(m, b)
}
func (m *Anchor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Anchor.Marshal(b, m, deterministic)
}
func (dst *Anchor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Anchor.Merge(dst, src)
}
func (m *Anchor) XXX_Size() int {
	return xxx_messageInfo_Anchor.Size(m)
}
func (m *Anchor) XXX_DiscardUnknown() {
	xxx_messageInfo_Anchor.DiscardUnknown(m)
}

var xxx_messageInfo_Anchor proto.InternalMessageInfo

func (m *Anchor) GetType() Anchor_Type {
	if m != nil {
		return m.Type
	}
	return Anchor_ETH
}

func (m *Anchor) GetStatus() Anchor_Status {
	if m != nil {
		return m.Status
	}
	return Anchor_ERROR
}

func (m *Anchor) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Anchor) GetSupportedFormats() []Proof_Format {
	if m != nil {
		return m.SupportedFormats
	}
	return nil
}

// *
// Submit proof request
type SubmitProofRequest struct {
	// hash to be submitted
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// anchor type
	AnchorType Anchor_Type `protobuf:"varint,2,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// proof format
	Format Proof_Format `protobuf:"varint,3,opt,name=format,proto3,enum=anchor.Proof_Format" json:"format,omitempty"`
	// whether to skip batching and submit a proof for the hash directly
	SkipBatching bool `protobuf:"varint,4,opt,name=skip_batching,json=skipBatching,proto3" json:"skip_batching,omitempty"`
	// whether to include the batch detail in the reply
	WithBatch            bool     `protobuf:"varint,5,opt,name=with_batch,json=withBatch,proto3" json:"with_batch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmitProofRequest) Reset()         { *m = SubmitProofRequest{} }
func (m *SubmitProofRequest) String() string { return proto.CompactTextString(m) }
func (*SubmitProofRequest) ProtoMessage()    {}
func (*SubmitProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{2}
}
func (m *SubmitProofRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubmitProofRequest.Unmarshal(m, b)
}
func (m *SubmitProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubmitProofRequest.Marshal(b, m, deterministic)
}
func (dst *SubmitProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitProofRequest.Merge(dst, src)
}
func (m *SubmitProofRequest) XXX_Size() int {
	return xxx_messageInfo_SubmitProofRequest.Size(m)
}
func (m *SubmitProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitProofRequest proto.InternalMessageInfo

func (m *SubmitProofRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *SubmitProofRequest) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *SubmitProofRequest) GetFormat() Proof_Format {
	if m != nil {
		return m.Format
	}
	return Proof_CHP_PATH
}

func (m *SubmitProofRequest) GetSkipBatching() bool {
	if m != nil {
		return m.SkipBatching
	}
	return false
}

func (m *SubmitProofRequest) GetWithBatch() bool {
	if m != nil {
		return m.WithBatch
	}
	return false
}

// *
// Batch request
type BatchRequest struct {
	// batch ID
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// anchor type
	AnchorType           Anchor_Type `protobuf:"varint,2,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BatchRequest) Reset()         { *m = BatchRequest{} }
func (m *BatchRequest) String() string { return proto.CompactTextString(m) }
func (*BatchRequest) ProtoMessage()    {}
func (*BatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{3}
}
func (m *BatchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchRequest.Unmarshal(m, b)
}
func (m *BatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchRequest.Marshal(b, m, deterministic)
}
func (dst *BatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchRequest.Merge(dst, src)
}
func (m *BatchRequest) XXX_Size() int {
	return xxx_messageInfo_BatchRequest.Size(m)
}
func (m *BatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchRequest proto.InternalMessageInfo

func (m *BatchRequest) GetBatchId() string {
	if m != nil {
		return m.BatchId
	}
	return ""
}

func (m *BatchRequest) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

// *
// Subscribe batches request
type SubscribeBatchesRequest struct {
	// batch filter. When nil, all batches will be subscribed; otherwise, only the
	// given anchor's batches will be subscribed; if batch_id is non-empty, only
	// the matched batch will be subscribed
	Filter               *BatchRequest `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SubscribeBatchesRequest) Reset()         { *m = SubscribeBatchesRequest{} }
func (m *SubscribeBatchesRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeBatchesRequest) ProtoMessage()    {}
func (*SubscribeBatchesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{4}
}
func (m *SubscribeBatchesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeBatchesRequest.Unmarshal(m, b)
}
func (m *SubscribeBatchesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeBatchesRequest.Marshal(b, m, deterministic)
}
func (dst *SubscribeBatchesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeBatchesRequest.Merge(dst, src)
}
func (m *SubscribeBatchesRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeBatchesRequest.Size(m)
}
func (m *SubscribeBatchesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeBatchesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeBatchesRequest proto.InternalMessageInfo

func (m *SubscribeBatchesRequest) GetFilter() *BatchRequest {
	if m != nil {
		return m.Filter
	}
	return nil
}

// *
// Batch detail
type Batch struct {
	// batch ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// anchor type
	AnchorType Anchor_Type `protobuf:"varint,2,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// proof format. It determines how the merkle tree is constructed for the
	// batch.
	ProofFormat Proof_Format `protobuf:"varint,3,opt,name=proof_format,json=proofFormat,proto3,enum=anchor.Proof_Format" json:"proof_format,omitempty"`
	// batch status. FLOW: created_at -> BATCHING -> flushed_at -> QUEUING ->
	// started_at -> PROCESSING -> submitted_at -> PENDING -> finalized_at ->
	// CONFIRMED / ERROR; * -> ERROR; when a batch has not yet reached PENDING and
	// its anchor has restarted, it will be put back to QUEUING
	Status Batch_Status `protobuf:"varint,4,opt,name=status,proto3,enum=anchor.Batch_Status" json:"status,omitempty"`
	// error message when status is ERROR
	Error string `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
	// number of hashes
	Size int64 `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	// created at timestamp. FLOW: created_at -> BATCHING
	CreatedAt *timestamp.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// flushed at timestamp. FLOW: BATCHING -> flushed_at -> QUEUING
	FlushedAt *timestamp.Timestamp `protobuf:"bytes,8,opt,name=flushed_at,json=flushedAt,proto3" json:"flushed_at,omitempty"`
	// started at timestamp. FLOW: QUEUING -> started_at -> PROCESSING
	StartedAt *timestamp.Timestamp `protobuf:"bytes,9,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// submitted at timestamp. FLOW: PROCESSING -> submitted_at -> PENDING
	SubmittedAt *timestamp.Timestamp `protobuf:"bytes,10,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
	// finalized at timestamp. FLOW: * -> finalized_at -> CONFIRMED / ERROR. NOTE:
	// this is not the real block confirmed time, use the timestamp in the batch
	// data instead.
	FinalizedAt *timestamp.Timestamp `protobuf:"bytes,11,opt,name=finalized_at,json=finalizedAt,proto3" json:"finalized_at,omitempty"`
	// batch root hash
	Hash string `protobuf:"bytes,12,opt,name=hash,proto3" json:"hash,omitempty"`
	// batch data in JSON
	Data                 string   `protobuf:"bytes,13,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Batch) Reset()         { *m = Batch{} }
func (m *Batch) String() string { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()    {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{5}
}
func (m *Batch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Batch.Unmarshal(m, b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
}
func (dst *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(dst, src)
}
func (m *Batch) XXX_Size() int {
	return xxx_messageInfo_Batch.Size(m)
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

func (m *Batch) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Batch) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *Batch) GetProofFormat() Proof_Format {
	if m != nil {
		return m.ProofFormat
	}
	return Proof_CHP_PATH
}

func (m *Batch) GetStatus() Batch_Status {
	if m != nil {
		return m.Status
	}
	return Batch_ERROR
}

func (m *Batch) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Batch) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Batch) GetCreatedAt() *timestamp.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Batch) GetFlushedAt() *timestamp.Timestamp {
	if m != nil {
		return m.FlushedAt
	}
	return nil
}

func (m *Batch) GetStartedAt() *timestamp.Timestamp {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *Batch) GetSubmittedAt() *timestamp.Timestamp {
	if m != nil {
		return m.SubmittedAt
	}
	return nil
}

func (m *Batch) GetFinalizedAt() *timestamp.Timestamp {
	if m != nil {
		return m.FinalizedAt
	}
	return nil
}

func (m *Batch) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Batch) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// *
// Proof request
type ProofRequest struct {
	// proof hash
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// proof batch ID
	BatchId string `protobuf:"bytes,2,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// anchor type
	AnchorType Anchor_Type `protobuf:"varint,3,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// whether to include the proof's batch detail
	WithBatch            bool     `protobuf:"varint,4,opt,name=with_batch,json=withBatch,proto3" json:"with_batch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProofRequest) Reset()         { *m = ProofRequest{} }
func (m *ProofRequest) String() string { return proto.CompactTextString(m) }
func (*ProofRequest) ProtoMessage()    {}
func (*ProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{6}
}
func (m *ProofRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProofRequest.Unmarshal(m, b)
}
func (m *ProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProofRequest.Marshal(b, m, deterministic)
}
func (dst *ProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofRequest.Merge(dst, src)
}
func (m *ProofRequest) XXX_Size() int {
	return xxx_messageInfo_ProofRequest.Size(m)
}
func (m *ProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProofRequest proto.InternalMessageInfo

func (m *ProofRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ProofRequest) GetBatchId() string {
	if m != nil {
		return m.BatchId
	}
	return ""
}

func (m *ProofRequest) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *ProofRequest) GetWithBatch() bool {
	if m != nil {
		return m.WithBatch
	}
	return false
}

// *
// Proof detail
type Proof struct {
	// proof hash
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// proof's batch ID
	BatchId string `protobuf:"bytes,2,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// anchor type
	AnchorType Anchor_Type `protobuf:"varint,3,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// proof status
	BatchStatus Batch_Status `protobuf:"varint,4,opt,name=batch_status,json=batchStatus,proto3,enum=anchor.Batch_Status" json:"batch_status,omitempty"`
	// proof format
	Format Proof_Format `protobuf:"varint,5,opt,name=format,proto3,enum=anchor.Proof_Format" json:"format,omitempty"`
	// proof data in base64
	Data string `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// proof's batch detail
	Batch                *Batch   `protobuf:"bytes,7,opt,name=batch,proto3" json:"batch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Proof) Reset()         { *m = Proof{} }
func (m *Proof) String() string { return proto.CompactTextString(m) }
func (*Proof) ProtoMessage()    {}
func (*Proof) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{7}
}
func (m *Proof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Proof.Unmarshal(m, b)
}
func (m *Proof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Proof.Marshal(b, m, deterministic)
}
func (dst *Proof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proof.Merge(dst, src)
}
func (m *Proof) XXX_Size() int {
	return xxx_messageInfo_Proof.Size(m)
}
func (m *Proof) XXX_DiscardUnknown() {
	xxx_messageInfo_Proof.DiscardUnknown(m)
}

var xxx_messageInfo_Proof proto.InternalMessageInfo

func (m *Proof) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Proof) GetBatchId() string {
	if m != nil {
		return m.BatchId
	}
	return ""
}

func (m *Proof) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *Proof) GetBatchStatus() Batch_Status {
	if m != nil {
		return m.BatchStatus
	}
	return Batch_ERROR
}

func (m *Proof) GetFormat() Proof_Format {
	if m != nil {
		return m.Format
	}
	return Proof_CHP_PATH
}

func (m *Proof) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Proof) GetBatch() *Batch {
	if m != nil {
		return m.Batch
	}
	return nil
}

// *
// Verify proof request
type VerifyProofRequest struct {
	// anchor type
	AnchorType Anchor_Type `protobuf:"varint,1,opt,name=anchor_type,json=anchorType,proto3,enum=anchor.Anchor_Type" json:"anchor_type,omitempty"`
	// proof format. If skipping the signature checking is desired, please use the
	// corresponding non-signed format, eg. use CHP_PATH instead of
	// CHP_PATH_SIGNED in request
	Format Proof_Format `protobuf:"varint,2,opt,name=format,proto3,enum=anchor.Proof_Format" json:"format,omitempty"`
	// proof data in base64
	Data                 string   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyProofRequest) Reset()         { *m = VerifyProofRequest{} }
func (m *VerifyProofRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyProofRequest) ProtoMessage()    {}
func (*VerifyProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{8}
}
func (m *VerifyProofRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VerifyProofRequest.Unmarshal(m, b)
}
func (m *VerifyProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VerifyProofRequest.Marshal(b, m, deterministic)
}
func (dst *VerifyProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyProofRequest.Merge(dst, src)
}
func (m *VerifyProofRequest) XXX_Size() int {
	return xxx_messageInfo_VerifyProofRequest.Size(m)
}
func (m *VerifyProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyProofRequest proto.InternalMessageInfo

func (m *VerifyProofRequest) GetAnchorType() Anchor_Type {
	if m != nil {
		return m.AnchorType
	}
	return Anchor_ETH
}

func (m *VerifyProofRequest) GetFormat() Proof_Format {
	if m != nil {
		return m.Format
	}
	return Proof_CHP_PATH
}

func (m *VerifyProofRequest) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// *
// Verify proof reply
type VerifyProofReply struct {
	// whether the proof is verified
	Verified bool `protobuf:"varint,1,opt,name=verified,proto3" json:"verified,omitempty"`
	// the error message when the proof is falsified
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// provenHash is the hash that is proven by current proof
	ProvenHash           string   `protobuf:"bytes,3,opt,name=provenHash,proto3" json:"provenHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyProofReply) Reset()         { *m = VerifyProofReply{} }
func (m *VerifyProofReply) String() string { return proto.CompactTextString(m) }
func (*VerifyProofReply) ProtoMessage()    {}
func (*VerifyProofReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_anchor_ca36d3b3879508e6, []int{9}
}
func (m *VerifyProofReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VerifyProofReply.Unmarshal(m, b)
}
func (m *VerifyProofReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VerifyProofReply.Marshal(b, m, deterministic)
}
func (dst *VerifyProofReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyProofReply.Merge(dst, src)
}
func (m *VerifyProofReply) XXX_Size() int {
	return xxx_messageInfo_VerifyProofReply.Size(m)
}
func (m *VerifyProofReply) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyProofReply.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyProofReply proto.InternalMessageInfo

func (m *VerifyProofReply) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

func (m *VerifyProofReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *VerifyProofReply) GetProvenHash() string {
	if m != nil {
		return m.ProvenHash
	}
	return ""
}

func init() {
	proto.RegisterType((*AnchorRequest)(nil), "anchor.AnchorRequest")
	proto.RegisterType((*Anchor)(nil), "anchor.Anchor")
	proto.RegisterType((*SubmitProofRequest)(nil), "anchor.SubmitProofRequest")
	proto.RegisterType((*BatchRequest)(nil), "anchor.BatchRequest")
	proto.RegisterType((*SubscribeBatchesRequest)(nil), "anchor.SubscribeBatchesRequest")
	proto.RegisterType((*Batch)(nil), "anchor.Batch")
	proto.RegisterType((*ProofRequest)(nil), "anchor.ProofRequest")
	proto.RegisterType((*Proof)(nil), "anchor.Proof")
	proto.RegisterType((*VerifyProofRequest)(nil), "anchor.VerifyProofRequest")
	proto.RegisterType((*VerifyProofReply)(nil), "anchor.VerifyProofReply")
	proto.RegisterEnum("anchor.Anchor_Type", Anchor_Type_name, Anchor_Type_value)
	proto.RegisterEnum("anchor.Anchor_Status", Anchor_Status_name, Anchor_Status_value)
	proto.RegisterEnum("anchor.Batch_Status", Batch_Status_name, Batch_Status_value)
	proto.RegisterEnum("anchor.Proof_Format", Proof_Format_name, Proof_Format_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AnchorServiceClient is the client API for AnchorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AnchorServiceClient interface {
	// get all anchors
	GetAnchors(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (AnchorService_GetAnchorsClient, error)
	// get an anchor
	GetAnchor(ctx context.Context, in *AnchorRequest, opts ...grpc.CallOption) (*Anchor, error)
	// get a proof
	GetProof(ctx context.Context, in *ProofRequest, opts ...grpc.CallOption) (*Proof, error)
	// submit a proof for the given hash
	SubmitProof(ctx context.Context, in *SubmitProofRequest, opts ...grpc.CallOption) (*Proof, error)
	// verify the given proof. When the proof is unverifiable, an exception is
	// thrown
	VerifyProof(ctx context.Context, in *VerifyProofRequest, opts ...grpc.CallOption) (*VerifyProofReply, error)
	// get a batch
	GetBatch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*Batch, error)
	// subscribe to batches
	SubscribeBatches(ctx context.Context, in *SubscribeBatchesRequest, opts ...grpc.CallOption) (AnchorService_SubscribeBatchesClient, error)
}

type anchorServiceClient struct {
	cc *grpc.ClientConn
}

func NewAnchorServiceClient(cc *grpc.ClientConn) AnchorServiceClient {
	return &anchorServiceClient{cc}
}

func (c *anchorServiceClient) GetAnchors(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (AnchorService_GetAnchorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AnchorService_serviceDesc.Streams[0], "/anchor.AnchorService/GetAnchors", opts...)
	if err != nil {
		return nil, err
	}
	x := &anchorServiceGetAnchorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AnchorService_GetAnchorsClient interface {
	Recv() (*Anchor, error)
	grpc.ClientStream
}

type anchorServiceGetAnchorsClient struct {
	grpc.ClientStream
}

func (x *anchorServiceGetAnchorsClient) Recv() (*Anchor, error) {
	m := new(Anchor)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *anchorServiceClient) GetAnchor(ctx context.Context, in *AnchorRequest, opts ...grpc.CallOption) (*Anchor, error) {
	out := new(Anchor)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/GetAnchor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) GetProof(ctx context.Context, in *ProofRequest, opts ...grpc.CallOption) (*Proof, error) {
	out := new(Proof)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/GetProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) SubmitProof(ctx context.Context, in *SubmitProofRequest, opts ...grpc.CallOption) (*Proof, error) {
	out := new(Proof)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/SubmitProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) VerifyProof(ctx context.Context, in *VerifyProofRequest, opts ...grpc.CallOption) (*VerifyProofReply, error) {
	out := new(VerifyProofReply)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/VerifyProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) GetBatch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*Batch, error) {
	out := new(Batch)
	err := c.cc.Invoke(ctx, "/anchor.AnchorService/GetBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *anchorServiceClient) SubscribeBatches(ctx context.Context, in *SubscribeBatchesRequest, opts ...grpc.CallOption) (AnchorService_SubscribeBatchesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AnchorService_serviceDesc.Streams[1], "/anchor.AnchorService/SubscribeBatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &anchorServiceSubscribeBatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AnchorService_SubscribeBatchesClient interface {
	Recv() (*Batch, error)
	grpc.ClientStream
}

type anchorServiceSubscribeBatchesClient struct {
	grpc.ClientStream
}

func (x *anchorServiceSubscribeBatchesClient) Recv() (*Batch, error) {
	m := new(Batch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AnchorServiceServer is the server API for AnchorService service.
type AnchorServiceServer interface {
	// get all anchors
	GetAnchors(*empty.Empty, AnchorService_GetAnchorsServer) error
	// get an anchor
	GetAnchor(context.Context, *AnchorRequest) (*Anchor, error)
	// get a proof
	GetProof(context.Context, *ProofRequest) (*Proof, error)
	// submit a proof for the given hash
	SubmitProof(context.Context, *SubmitProofRequest) (*Proof, error)
	// verify the given proof. When the proof is unverifiable, an exception is
	// thrown
	VerifyProof(context.Context, *VerifyProofRequest) (*VerifyProofReply, error)
	// get a batch
	GetBatch(context.Context, *BatchRequest) (*Batch, error)
	// subscribe to batches
	SubscribeBatches(*SubscribeBatchesRequest, AnchorService_SubscribeBatchesServer) error
}

func RegisterAnchorServiceServer(s *grpc.Server, srv AnchorServiceServer) {
	s.RegisterService(&_AnchorService_serviceDesc, srv)
}

func _AnchorService_GetAnchors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AnchorServiceServer).GetAnchors(m, &anchorServiceGetAnchorsServer{stream})
}

type AnchorService_GetAnchorsServer interface {
	Send(*Anchor) error
	grpc.ServerStream
}

type anchorServiceGetAnchorsServer struct {
	grpc.ServerStream
}

func (x *anchorServiceGetAnchorsServer) Send(m *Anchor) error {
	return x.ServerStream.SendMsg(m)
}

func _AnchorService_GetAnchor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).GetAnchor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/GetAnchor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).GetAnchor(ctx, req.(*AnchorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_GetProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).GetProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/GetProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).GetProof(ctx, req.(*ProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_SubmitProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).SubmitProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/SubmitProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).SubmitProof(ctx, req.(*SubmitProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_VerifyProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).VerifyProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/VerifyProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).VerifyProof(ctx, req.(*VerifyProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_GetBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnchorServiceServer).GetBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.AnchorService/GetBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnchorServiceServer).GetBatch(ctx, req.(*BatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnchorService_SubscribeBatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeBatchesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AnchorServiceServer).SubscribeBatches(m, &anchorServiceSubscribeBatchesServer{stream})
}

type AnchorService_SubscribeBatchesServer interface {
	Send(*Batch) error
	grpc.ServerStream
}

type anchorServiceSubscribeBatchesServer struct {
	grpc.ServerStream
}

func (x *anchorServiceSubscribeBatchesServer) Send(m *Batch) error {
	return x.ServerStream.SendMsg(m)
}

var _AnchorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "anchor.AnchorService",
	HandlerType: (*AnchorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAnchor",
			Handler:    _AnchorService_GetAnchor_Handler,
		},
		{
			MethodName: "GetProof",
			Handler:    _AnchorService_GetProof_Handler,
		},
		{
			MethodName: "SubmitProof",
			Handler:    _AnchorService_SubmitProof_Handler,
		},
		{
			MethodName: "VerifyProof",
			Handler:    _AnchorService_VerifyProof_Handler,
		},
		{
			MethodName: "GetBatch",
			Handler:    _AnchorService_GetBatch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAnchors",
			Handler:       _AnchorService_GetAnchors_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeBatches",
			Handler:       _AnchorService_SubscribeBatches_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "anchor/anchor.proto",
}

func init() { proto.RegisterFile("anchor/anchor.proto", fileDescriptor_anchor_ca36d3b3879508e6) }

var fileDescriptor_anchor_ca36d3b3879508e6 = []byte{
	// 1062 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4d, 0x72, 0xdb, 0x46,
	0x13, 0x15, 0xfe, 0x28, 0xb2, 0x01, 0xca, 0xf8, 0x46, 0xfe, 0x12, 0x98, 0xa9, 0xc4, 0x2a, 0x78,
	0x11, 0x2d, 0x22, 0xc8, 0x51, 0x5c, 0x65, 0xc7, 0x55, 0x59, 0x80, 0x14, 0x24, 0xb2, 0x2a, 0xa6,
	0x10, 0x00, 0xca, 0xc2, 0x1b, 0x16, 0x48, 0x0e, 0x45, 0x94, 0x48, 0x02, 0x01, 0x86, 0x72, 0xe8,
	0x33, 0x64, 0x93, 0x1c, 0x21, 0x27, 0xc8, 0x09, 0x72, 0x86, 0x1c, 0x20, 0x87, 0x49, 0xcd, 0x0c,
	0x40, 0x82, 0xa4, 0x14, 0xc9, 0x5e, 0x64, 0x45, 0x76, 0xf7, 0xeb, 0x99, 0x9e, 0x37, 0x78, 0xdd,
	0x03, 0xfb, 0xe1, 0x6c, 0x30, 0x8e, 0xd3, 0x63, 0xfe, 0x63, 0x25, 0x69, 0x4c, 0x62, 0x54, 0xe1,
	0x56, 0xe3, 0xb3, 0xab, 0x38, 0xbe, 0x9a, 0xe0, 0x63, 0xe6, 0xed, 0xcf, 0x47, 0xc7, 0x78, 0x9a,
	0x90, 0x05, 0x07, 0x35, 0x9e, 0x6e, 0x06, 0x49, 0x34, 0xc5, 0x19, 0x09, 0xa7, 0x09, 0x07, 0x98,
	0xaf, 0xa0, 0x6e, 0xb3, 0x75, 0x3c, 0xfc, 0xd3, 0x1c, 0x67, 0x04, 0x7d, 0x09, 0x32, 0x59, 0x24,
	0xd8, 0x10, 0x0e, 0x84, 0xc3, 0xbd, 0x93, 0x7d, 0x2b, 0xdf, 0x93, 0x83, 0xac, 0x60, 0x91, 0x60,
	0x8f, 0x01, 0xcc, 0x3f, 0x45, 0xa8, 0x70, 0xef, 0x83, 0x73, 0xd0, 0x11, 0x54, 0x32, 0x12, 0x92,
	0x79, 0x66, 0x88, 0x0c, 0xfa, 0xff, 0x0d, 0xa8, 0xcf, 0x82, 0x5e, 0x0e, 0x42, 0x8f, 0x41, 0xc1,
	0x69, 0x1a, 0xa7, 0x86, 0x74, 0x20, 0x1c, 0xd6, 0x3c, 0x6e, 0x20, 0x1b, 0xfe, 0x97, 0xcd, 0x93,
	0x24, 0x4e, 0x09, 0x1e, 0xf6, 0x46, 0x71, 0x3a, 0x0d, 0x49, 0x66, 0xc8, 0x07, 0xd2, 0xe1, 0xde,
	0xc9, 0xe3, 0x62, 0x3d, 0x37, 0x8d, 0xe3, 0x91, 0x75, 0xc6, 0x82, 0x9e, 0xbe, 0x84, 0x73, 0x47,
	0x66, 0x06, 0x20, 0xd3, 0xaa, 0xd0, 0x2e, 0x48, 0x4e, 0xd0, 0xd6, 0x77, 0xd0, 0x23, 0x50, 0x9d,
	0xa0, 0xdd, 0x7b, 0x63, 0x77, 0xba, 0x5d, 0x27, 0xd0, 0xa5, 0xc2, 0xe1, 0x7c, 0x6f, 0xfb, 0xc1,
	0x85, 0xaf, 0xcb, 0x14, 0xda, 0x0c, 0x5a, 0xba, 0x40, 0x23, 0xcd, 0xa0, 0xb5, 0x84, 0x2a, 0x34,
	0xd2, 0x6a, 0xbb, 0xba, 0x68, 0x1e, 0x41, 0x85, 0x1f, 0x00, 0xd5, 0x40, 0x71, 0x3c, 0xef, 0xc2,
	0xd3, 0x77, 0x90, 0x0a, 0xbb, 0x7e, 0x70, 0xe1, 0xba, 0xce, 0xa9, 0x2e, 0x50, 0xc3, 0xbb, 0xec,
	0x76, 0x3b, 0xdd, 0x73, 0x5d, 0x34, 0xff, 0x12, 0x00, 0xf9, 0xf3, 0xfe, 0x34, 0x22, 0xac, 0xda,
	0xe2, 0x02, 0x10, 0xc8, 0xe3, 0x30, 0x1b, 0x33, 0x32, 0x6b, 0x1e, 0xfb, 0x8f, 0x5e, 0x80, 0xca,
	0x0f, 0xd6, 0x63, 0x3c, 0x8b, 0x77, 0xf3, 0x0c, 0xdc, 0xc7, 0x4e, 0xf7, 0x15, 0x54, 0x38, 0x3d,
	0x8c, 0xbf, 0xbb, 0xd8, 0xc9, 0x31, 0xe8, 0x19, 0xd4, 0xb3, 0xeb, 0x28, 0xe9, 0xf5, 0x43, 0x32,
	0x18, 0x47, 0xb3, 0x2b, 0x43, 0x3e, 0x10, 0x0e, 0xab, 0x9e, 0x46, 0x9d, 0xcd, 0xdc, 0x87, 0x3e,
	0x07, 0x78, 0x17, 0x91, 0x31, 0x07, 0x19, 0x0a, 0x43, 0xd4, 0xa8, 0x87, 0x21, 0xcc, 0x1e, 0x68,
	0xec, 0x4f, 0x71, 0x96, 0x27, 0x50, 0x65, 0xc8, 0x5e, 0x34, 0xcc, 0xcf, 0xb3, 0xcb, 0xec, 0xce,
	0xf0, 0xe3, 0x8e, 0x64, 0x9e, 0xc3, 0xa7, 0xfe, 0xbc, 0x9f, 0x0d, 0xd2, 0xa8, 0x8f, 0xd9, 0x4e,
	0x38, 0x2b, 0xf6, 0xa2, 0xa7, 0x8d, 0x26, 0x04, 0xa7, 0x6c, 0x27, 0x75, 0x75, 0xda, 0x72, 0x45,
	0x5e, 0x8e, 0x31, 0x7f, 0x55, 0x40, 0x61, 0x01, 0xb4, 0x07, 0xe2, 0xb2, 0x3a, 0x31, 0xfa, 0xc8,
	0xc2, 0xd0, 0x4b, 0xd0, 0x12, 0xca, 0x6a, 0xef, 0x01, 0x8c, 0xab, 0x0c, 0xc9, 0x0d, 0x5a, 0x76,
	0x2e, 0x09, 0x79, 0x3d, 0x85, 0x55, 0x77, 0xa7, 0x22, 0x94, 0xb2, 0x22, 0x10, 0xc8, 0x59, 0xf4,
	0x1e, 0x1b, 0x95, 0x03, 0xe1, 0x50, 0xf2, 0xd8, 0x7f, 0xf4, 0x2d, 0xc0, 0x20, 0xc5, 0x21, 0xd5,
	0x48, 0x48, 0x8c, 0x5d, 0x46, 0x49, 0xc3, 0xe2, 0xed, 0xc0, 0x2a, 0xda, 0x81, 0x15, 0x14, 0xed,
	0xc0, 0xab, 0xe5, 0x68, 0x9b, 0xd0, 0xd4, 0xd1, 0x64, 0x9e, 0x8d, 0x79, 0x6a, 0xf5, 0xfe, 0xd4,
	0x1c, 0xcd, 0x53, 0x33, 0x12, 0xa6, 0xf9, 0xae, 0xb5, 0xfb, 0x53, 0x73, 0xb4, 0x4d, 0xd0, 0x77,
	0xa0, 0x65, 0x4c, 0x0d, 0x79, 0x32, 0xdc, 0x9b, 0xac, 0x2e, 0xf1, 0x3c, 0x7d, 0x14, 0xcd, 0xc2,
	0x49, 0xf4, 0x9e, 0xa7, 0xab, 0xf7, 0xa7, 0x2f, 0xf1, 0xf6, 0x4a, 0x75, 0x5a, 0x49, 0x75, 0x08,
	0xe4, 0x61, 0x48, 0x42, 0xa3, 0xce, 0x7d, 0xf4, 0xbf, 0xf9, 0xf6, 0x36, 0x8d, 0x6b, 0x50, 0x6d,
	0xda, 0x41, 0xab, 0x4d, 0x75, 0xcd, 0x44, 0xfe, 0xc3, 0xa5, 0x73, 0xc9, 0x44, 0x8e, 0xf6, 0x00,
	0x5c, 0xef, 0xa2, 0xe5, 0xf8, 0x3e, 0xb5, 0x25, 0x1a, 0x74, 0x9d, 0xee, 0x29, 0x35, 0x64, 0x54,
	0x87, 0x5a, 0xeb, 0xa2, 0x7b, 0xd6, 0xf1, 0xde, 0x38, 0xa7, 0xba, 0x62, 0xfe, 0x26, 0x80, 0x76,
	0x6f, 0x2b, 0x28, 0x4b, 0x4a, 0xfc, 0x57, 0x49, 0x49, 0x0f, 0xfb, 0x72, 0xd7, 0x25, 0x2d, 0x6f,
	0x4a, 0xfa, 0x6f, 0x11, 0x14, 0x56, 0xd4, 0x7f, 0x53, 0xcd, 0x4b, 0xd0, 0xf8, 0x82, 0x0f, 0x10,
	0x85, 0xca, 0x90, 0xf9, 0x75, 0xac, 0x9a, 0x9d, 0xf2, 0x80, 0x66, 0x57, 0x5c, 0x6d, 0x65, 0x75,
	0xb5, 0xe8, 0x19, 0x28, 0x9c, 0x03, 0x2e, 0x96, 0xfa, 0x7a, 0xff, 0xe0, 0x31, 0xb3, 0x0b, 0x95,
	0x5c, 0xb8, 0x1a, 0x54, 0x5b, 0x6d, 0xb7, 0xe7, 0xda, 0x6c, 0x80, 0x68, 0x50, 0xa5, 0xf3, 0x22,
	0xf0, 0x3a, 0x8e, 0x2e, 0xa0, 0x7d, 0x78, 0x54, 0xc4, 0x7a, 0x7e, 0xe7, 0xbc, 0xeb, 0x9c, 0xea,
	0x22, 0x75, 0x16, 0x90, 0xc2, 0x29, 0x99, 0xbf, 0x08, 0x80, 0x7e, 0xc4, 0x69, 0x34, 0x5a, 0xac,
	0xdd, 0xfc, 0x06, 0x79, 0xc2, 0x87, 0x36, 0x7c, 0xf1, 0x03, 0x38, 0x90, 0x4a, 0x9f, 0xf7, 0x10,
	0xf4, 0xb5, 0x6a, 0x92, 0xc9, 0x02, 0x35, 0xa0, 0x7a, 0x43, 0x7d, 0x11, 0xe6, 0x6d, 0xb2, 0xea,
	0x2d, 0xed, 0x55, 0x3f, 0x12, 0xcb, 0xfd, 0xe8, 0x0b, 0x80, 0x24, 0x8d, 0x6f, 0xf0, 0xac, 0x4d,
	0xbf, 0x17, 0xbe, 0x7e, 0xc9, 0x73, 0xf2, 0x87, 0x54, 0xbc, 0x3a, 0x7c, 0x9c, 0xde, 0x44, 0x03,
	0x8c, 0x5e, 0x01, 0x9c, 0x63, 0xc2, 0x7d, 0x19, 0xfa, 0x64, 0x4b, 0xb5, 0x0e, 0x7d, 0xd3, 0x34,
	0xf6, 0xd6, 0x09, 0x30, 0x77, 0x9e, 0x0b, 0xe8, 0x05, 0xd4, 0x96, 0x99, 0x68, 0xe3, 0x3d, 0x91,
	0xb3, 0xb9, 0x9d, 0x87, 0xbe, 0x86, 0xea, 0x39, 0xe6, 0x73, 0x17, 0xad, 0xb3, 0x54, 0xe4, 0xd4,
	0xd7, 0xbc, 0xe6, 0x0e, 0x7a, 0x0d, 0x6a, 0x69, 0x5a, 0xa3, 0x46, 0x11, 0xdf, 0x1e, 0xe1, 0xdb,
	0xb9, 0x0e, 0xa8, 0x25, 0x5a, 0x57, 0xb9, 0xdb, 0x37, 0xdf, 0x30, 0x6e, 0x8d, 0x25, 0x93, 0xc5,
	0xb2, 0x6a, 0x3e, 0xb6, 0x6e, 0x1d, 0x6f, 0x8d, 0xf5, 0x8f, 0xd6, 0xdc, 0x41, 0x67, 0xa0, 0x6f,
	0x0e, 0x4c, 0xf4, 0xb4, 0x54, 0xfa, 0x6d, 0xa3, 0x74, 0x6b, 0x95, 0xe7, 0x42, 0x73, 0x02, 0x4f,
	0x06, 0xf1, 0xd4, 0xe2, 0x97, 0x38, 0xec, 0x5b, 0xe5, 0xa7, 0x68, 0x53, 0xe5, 0xbc, 0xba, 0xd4,
	0x70, 0x85, 0xb7, 0xaf, 0xaf, 0x22, 0x32, 0x9e, 0xf7, 0xad, 0x41, 0x3c, 0x3d, 0xf6, 0xe3, 0x39,
	0x19, 0xf7, 0xc3, 0xd9, 0xb5, 0x1f, 0x8f, 0xc8, 0xbb, 0x30, 0x65, 0x4f, 0xd1, 0x1b, 0x3c, 0xfb,
	0xf9, 0x68, 0x30, 0x89, 0x8e, 0x93, 0xeb, 0x2b, 0xfe, 0x34, 0xcd, 0xf2, 0xb7, 0xed, 0xef, 0xa2,
	0x64, 0xb7, 0xda, 0xfd, 0x0a, 0x73, 0x7e, 0xf3, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x92, 0x07,
	0xe2, 0x7b, 0xf9, 0x0a, 0x00, 0x00,
}
